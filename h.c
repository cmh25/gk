#include "h.h"
#include <stdio.h>

void help(int a) {
  if(!a) {
    fprintf(stderr,""
"\\0 data\n"
"\\+ verbs\n"
"\\' adverbs\n"
"\\_ reserved verbs/nouns\n"
"\\. assign define control debug\n"
"\\: input/output\n"
"\\- client/server\n"
"\\` os commands\n"
"\\? commands\n");
  }
  else if(a=='0') {
    fprintf(stderr,""
"       scalar  vector  empty  inf  nul\n"
"int    0       1 2     !0     0I   0N\n"
"float  0.0     1 2.0   0#0.0  0i   0n\n"
"char   \" \"     \"12\"    \"\"          \"\\0\"\n"
"symbol `       `a`b    0#`\n"
"\n"
"lambda {}\n"
"null   nul\n"
"list   (a;b;c;...) ,a () empty\n"
"\n"
"dict   .((`a;1);(`b;2);...)\n"
" !d    keys\n"
" d[]   values\n"
" d.k  d`k  d[`k]  d@`k  d.`k\n"
"\n"
"4:x    type: atom(1..7)[ifcsdnx] list(0..-4)[KIFCS]\n"
"5:x    ascii representation\n");
  }
  else if(a=='+') {
    fprintf(stderr,""
"   monad      dyad\n"
"+  flip       plus\n"
"-  negate     minus\n"
"*  first      times\n"
"%%  recip      divide\n"
"&  where      min/and\n"
"|  reverse    max/or\n"
"<  upgrade    less\n"
">  downgrade  more\n"
"=  group      equal\n"
"^  shape      power\n"
"!  enumerate  mod/rotate\n"
"~  not        match\n"
",  enlist     join\n"
"#  count      take/reshape\n"
"_  floor      drop/cut\n"
"$  format     form\n"
"?  unique     find/draw/deal\n"
"@  atom       at\n"
".  value      dot\n"
"\n"
"   triad      tetrad\n"
"_  slide\n"
"@  amend/trap amend\n"
".  amend/trap amend\n");
  }
  else if(a=='\'') {
    fprintf(stderr,""
"each       f'x\n"
"each       x f'y\n"
"each       f'[x;y]\n"
"each       f'[x;y;z]\n"
"\n"
"scanm      f\\x\n"
"do         n f\\x\n"
"while      b f\\x\n"
"eachleft   x f\\y\n"
"eachleft   f\\[x;y]\n"
"scand      f\\x\n"
"scan       f\\[x;y;z]\n"
"\n"
"overm      f/x\n"
"do         n f/x\n"
"while      b f/x\n"
"eachright  x f/y\n"
"eachright  f/[x;y]\n"
"overd      f/x\n"
"over       f/[x;y;z]\n"
"\n"
"eachprior  ep[f;x]\n");
  }
  else if(a=='_') {
    fprintf(stderr,""
"variables/constants:\n"
"      nul   null\n"
"      .z.h  hostname\n"
"      .z.P  pid\n"
"      .z.i  cli args\n"
"      .z.T  days since 2035 (float)\n"
"      .z.t  seconds since 2035 (int)\n"
"      .z.f  self reference to current function\n"
"\n"
"math: log exp abs sqr sqrt floor ceil dot mul\n"
"      sin cos tan asin acos atan sinh cosh tanh x atan2 y\n"
"      x euclid y (hypot) erf erfc gamma lgamma (log gamma) n choose k\n"
"      rint (round to whole number) x round y (round to y) trunc (nearest)\n"
"      div  and or xor not rot shift (bitwise)\n"
"      y lsq A (least squares approximation, y~+/A*lsq[y;A])\n"
"      inv A (inverse A, I~A mul inv A)\n"
"      svd A (singular value decomposition (U;S;+V), A~mul/svd A)\n"
"      lu A (lower/upper decomposition (+P;L;U), A~mul/lu A)\n"
"      ldu A (lower/diag/upper decomposition (+P;L;D;U), A~mul/ldu A)\n"
"      rref A (reduced row echelon form)\n"
"      qr A (qr decomposition (Q;R), A~mul/qr A\n"
"\n"
"rand: x draw y (from !y); x draw -y (deal from !y); x draw 0 (from (0,1))\n"
"\n"
"time: lt ts (local timestamp, days since 2035)\n"
"      ltime ts (local day time, ex: 20231225 123005)\n"
"      gtime ts (gmt day time)\n"
"      jd yyyymmdd (and dj) to/from julian day number (0 is monday)\n"
"      sleep ms\n"
"\n"
"list: x at y indexes giving appropriate null values instead of index error\n"
"      x in y is 1 if x is an item of y; 0 otherwise (list: lin)\n"
"      x dv y and x di y to delete by value and index (list: dvl)\n"
"      x sv v (scalar from vector) and x vs s (vector from scalar)\n"
"      ci i (character from integer) and ic c (integer from character)\n"
"      x sm y is string match. y can have *?[^-].\n"
"      x ss y is string/symbol search for start indices. y can have ?[^-].\n"
"      ssr[x;y;z] is string/symbol search and replace. z can be a function.\n"
"\n"
"data: bd d (bytes from data)  and db b (data from bytes)\n"
"      bh d (bytes from hex)   and hb b (hex from bytes)\n"
"      zb b (compress bytes)   and bz z (decompress bytes)\n"
"      kv v (list from vector) and vk k (vector from list)\n"
"      val f (valence of fun)\n"
"      md5 x (128-bit), sha1 x (160-bit), sha2 x (256-bit)\n"
"        x is type -3 4 -4 0\n"
"      (iv;key) encrypt x, (iv;key) decrypt x (aes256)\n"
"        x is type -3 4 -4 0, iv:16 draw 256, key:32 draw 256\n"
"\n"
"sys:  v setenv s, getenv v (set/get environment variable)\n"
"      del f (delete file), f rename g (rename f to g)\n"
"      exit code\n");
  }
  else if(a=='.') {
    fprintf(stderr,""
"assign\n"
"a:1   local\n"
"a::1  global\n"
"\n"
"amend\n"
".[d;i;f]   @[d;i;f]\n"
".[d;i;f;y] @[d;i;f;y]\n"
"\n"
"control\n"
" $[c;t;f]   conditional\n"
" if[c;...]\n"
" do[n;...]\n"
" while[c;...]\n"
" /  comment\n"
" \\  abort/trace\n"
" :  return\n"
" '  signal\n"
"\n"
"error trap .[f;(x;y;z);:] and @[f;x;:]\n");
  }
  else if(a==':') {
    fprintf(stderr,""
" 0:f   f 0:x  read/write text (` for console)\n"
" 1:f   f 1:x  read (map)/write k data\n"
"       f 5:x  append k data\n"
" 2:f          read k data\n"
" 6:f   f 6:x  read/write bytes\n"
"     (,f)6:x  append bytes\n"
"\n"
" (type;width)0:f   fixedwidth text(IFCS )\n"
" (type;width)1:f   fixedwidth data(cbsifd CS)\n"
" blank skips. f can be (f;index;length).\n");
  }
  else if(a=='-') {
    fprintf(stderr,""
"coming soon...\n");
  }
  else if(a=='`') {
    fprintf(stderr,""
"`3:\"cmd\"  set\n"
"`4:\"cmd\"  get stdout\n"
"`8:\"cmd\"  get (rc;stdout;stderr)\n");
  }
  else if(a=='?') {
    fprintf(stderr,""
"\\d [d|^]  k directory [go to]\n"
"\\e [0|1]  error flag [off|on]\n"
"\\l f      load script f\n"
"\\p [n]    print precision\n"
"\\t x      time in milliseconds to execute x\n"
"\\v        variables\n"
"\\V        variables (long listing)\n"
"\\zc [0|1] zeroclamp printing to fabs(1e-12)\n");
  }
}
